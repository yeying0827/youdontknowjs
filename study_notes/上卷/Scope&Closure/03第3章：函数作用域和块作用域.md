## 第3章 函数作用域和块作用域

作用域”气泡“排列的结构是在写代码时定义的。



### 3.1 函数中的作用域

JavaScript只具有基于函数的作用域？事实上这并不完全正确。

无法从函数的外部对附属于函数作用域的变量和内部函数进行访问。

**函数作用域的含义**是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。

=> 能充分利用JavaScript变量可以**根据需要改变值类型**的”动态“特性。

如果不细心处理那些可以在整个作用域范围内被访问的变量，可能会带来意想不到的问题。



### 3.2 隐藏内部实现

对函数的**传统认知**是先声明一个函数，再向里面添加代码。

反过来想=> 从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码”**隐藏**“了。

实际结果就是，**在这个代码片段的周围创建了一个作用域气泡** => 即，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来”隐藏“它们。 => 代码中的任何声明（变量或函数）都将**绑定在这个新创建的包装函数的作用域中**。[基于作用域的隐藏方法]

为什么“隐藏”变量和函数是一个有用的技术？=> **最小特权原则**，也叫最小授权或最小暴露原则（软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计）

给予外部作用域对本应私有的变量和函数的“访问权限”不仅没有必要，而且可能是“危险”的，因为它们可能被有意或无意地**以非预期的方式使用**，从而导致超出了适用条件，更“合理”的设计会将这些私有的具体内容隐藏在包装函数内部。=> 设计良好的软件

“隐藏”作用域中的变量和函数所**带来的的另一个好处**是：可以**避免同名标识符之间的冲突**。两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突，冲突会导致变量的值被意外覆盖。

🌰：

```javascript
function foo() {
  function bar( a ) {
    i = 3; // 修改for循环所属作用域i
    console.log( a + i );
  }
  for( var i = 0; i < 10; i ++ ) {
    bar( i * 2); // 无限循环了！
  }
}
foo();
```

修改（声明一个本地变量在`bar(...)`内部使用，任何名字都可以）：

1. `var i = 3;`就可以满足（同时会为i声明一个前面提过的“遮蔽变量”）
2. 采用一个完全不同的标识符名称，如`var j = 3;`

软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，这种情况使用作用域来“隐藏”内部声明是唯一的最佳选择。

**解决命名冲突的常见方式：**

1. 全局命名空间

   加载**多个第三方库**，如果没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

   这些库通常会**在全局作用域中**声明一个**名字足够独特的变量**，**通常是一个对象**。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。

2. 模块管理

   另一种避免冲突的办法，就是从众多模块管理器中挑选一个来使用。

   使用模块管理器，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符**显式**地**导入到**另外一个**特定**的作用域中。

   这些工具**利用作用域的规则** ***强制*** 所有标识符都***不能***注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。

   => 模块模式（第5章）



### 3.3 函数作用域

在任意代码片段外部添加包装函数，如：

```javascript
var a = 2;
function foo() { // <-- 添加这一行
  var a = 3;
  console.log( a );
} // <-- 以及这一行
foo(); // <-- 以及这一行
console.log( a );
```

虽然可以解决一些问题，但是它并不理想，因为会**导致一些额外的问题**：

1. 必须声明一个具名函数`foo()`，意味着foo这个名称本身“污染”了所在作用域；
2. 必须显式地通过函数名`foo()`调用这个函数才能运行其中的代码。

如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。

=> JavaScript提供了能够同时解决这两个问题的方案：

```javascript
var a = 2;
(function foo() { // <-- 添加这一行
  var a = 3;
  console.log( a );
})(); // <-- 以及这一行
console.log( a );
```

包装函数的声明以`(function ...`而不仅是以`function ...`开始。 => 函数会被当作**函数表达式**而不是一个标准的函数声明来处理。

**区分函数声明和表达式**最简单的方法是看`function`关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果`function`是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

**函数声明和函数表达式之间最重要的区别**，是它们的名称标识符将会绑定在何处。

第一种foo被绑定在所在作用域中，可以直接通过foo()来调用它；**第二种**foo被绑定在<u>函数表达式自身的函数</u>中而不是所在作用域中。

=> 即，`(function foo() { ... })`作为函数表达式意味着foo只能在`...`所代表的位置中被访问，**外部作用域则不行**。foo变量名被隐藏在自身中意味着**不会非必要地污染外部作用域**。

#### 3.3.1 匿名和具名

函数表达式最常见场景就是回调参数。如：

```javascript
setTimeout( function() {
  // ...
}, 1000 );
```

这是**匿名函数表达式**。function没有名称标识符。函数表达式可以匿名，函数声明则不可以省略函数名——JavaScript语法中这是非法的。

**匿名函数表达式书写简单快捷，但是也有几个缺点**：

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得**调试困难**。
2. 当函数需要**引用自身时**只能使用<u>已经过期</u>的`arguments.callee`引用。如递归，或是在事件触发后事件监听器需要解绑自身。
3. 降低了代码**可读性/可理解性**

**行内函数表达式**非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。<u>给函数表达式指定一个函数名可以有效解决以上问题。</u>始终给函数表达式命名是一个最佳实践：

```javascript
setTimeout( function timeoutHandler() {
  // ...
}, 1000 );
```

####3.3.2 立即执行函数表达式(IIFE)

```javascript
var a = 2;
(function foo() {
  var a = 3;
  console.log( a );
})();
console.log( a );
```

由于函数被包含在一对`()`里，因此成为了一个表达式，通过在末尾加上另外一个`()`可以立即执行这个函数，比如`(function foo() {...})();`。第一个括号将函数变成表达式，第二个括号执行了这个函数。

IIFE(Immediately Invoked Function Expresssion)。**函数名对IIFE不是必须的**，IIFE**最常见的用法是使用一个匿名函数表达式**。（虽然使用具名函数的IIFE不常见，但它具有上述匿名函数表达式的所有优势(?)，因此也是一个值得推广的实践）

IIFE还有另一个改进的形式：`(function foo(){...}())`。用来调用的括号被移进了用来包装的括号中。这两种形式在功能上是一致的。

IIFE**另一个非常普遍的进阶用法是，把它们当作函数调用并传递参数进去**。

🌰：

```javascript
var a = 2;
(function IIFE( global ) {
  var a = 3;
  console.log( a );
  console.log( global.a );
})( window );
console.log( a );
```

可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。=> 对**改进代码风格**非常有帮助

IIFE的**另外一个应用场景**是，解决undefined标识符的默认值被错误覆盖导致的异常（不常见）（什么情况下会发生？？）

```javascript
undefined = true;
(function IIFE( undefined ) {
  var a;
  if( a === undefined ) {
    console.log( "Undefined is safe here!" );
  }
})();
```

IIFE还有**一种变化的用途是倒置代码的运行顺序**，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去。这种模式在UMD(Universal Module Definition)项目中被广泛使用。尽管略显冗长，但有些人认为它更易理解。

```javascript
var a = 2;
(function IIFE( def ) {
  def( window );
})(function def( global ) {
  var a = 3;
  console.log( a );
  console.log( global.a );
});
```

函数表达式def**定义**在片段的第二部分；然后当作参数**被传递进**IIFE函数定义的第一部分中；最后参数def（也就是传递进去的函数）**被调用**，并将window传入当作global参数的值。



### 3.4 块作用域

**函数作用域是最常见的作用域单元**，但通过使用其他类型的作用域单元甚至可以实现维护起来更加优秀、简洁的代码。

```javascript
for (var i=0; i<10; i++) {
  console.log( i );
}
```

通常只想在for循环内部的上下文中使用i，但i会被绑定在外部作用域（函数或全局）中。

这就是**块作用域的用处**：变量的声明应该距离使用的地方越近越好，并最大限度地本地化。

```javascript
var foo = true;
if (foo) {
  var bar = foo * 2;
  bar = something( bar );
  console.log( bar );
}
```

当使用`var`声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。

上述代码是**为了风格更易读而伪装出的**形式上的块作用域，如果使用这种形式，要确保没在作用域其他地方意外地使用bar**只能依靠自觉性**。

块作用域是一个用来对之前的**最小授权原则**进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。

1）避免在作用范围外意外地使用（或复用）某些变量=>可能导致未知异常；2）提升代码的可维护性=>否则需要开发者自己检查代码

**JavaScript看似没有块作用域，但有一些特例。**

#### 3.4.1 with

块作用域的一个例子（块作用域的一种形式）。用`with`从对象中创建出的作用域仅在with声明中而非外部作用域中有效。

#### 3.4.2 try/catch

**ES3规范**中规定try/catch的**catch分句**会创建一个块作用域，其中声明的变量仅在catch内部有效。

🌰：

```javascript
try {
  undefined();
} catch (err) {
  console.log( err ); // TypeError: undefined is not a function
}
console.log( err ); // ReferenceError: err is not defined
```

当同一个作用域中的两个或多个catch分句用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。=> 使用不同的标识符名称，或者关闭静态检查工具对重复变量名的检查

🌰：

```javascript
{
  let a = 2;
  console.log( a ); // 2
}
console.log( a ); // ReferenceError
```

在ES6之前的环境中如何才能实现上述效果？答案是使用catch。

```javascript
try { throw 2; } catch (a) {
  console.log( a );
}
console.log( a );
```

catch分句具有块作用域，因此它可以在ES6之前的环境中作为块作用域的替代方案。=>  构建工具对代码预处理（这是向ES6中的大部分功能迁移的首选方式）

=> Google的Traceur项目

```javascript
{
  try {
    throw undefined;
  } catch(a) {
    a = 2;
    console.log( a );
  }
}
console.log( a );
```

**try/catch vs. IIFE**

try/catch性能糟糕，Traceur团队要求Chrome对try/catch的性能进行改进

IIFE和try/catch并不完全等价，因为如果将一段代码中的任意一部分拿出来用函数进行包裹，会改变这段代码的含义，其中的this、return、break和continue都会发生变化。

#### 3.4.3 let

ES6引入的新关键字

`let`关键字可以将变量绑定到所在的任意作用域中（通常是`{...}`内部）。=> 即，`let`为其声明的变量**隐式地**劫持了所在的块作用域

用`let`将变量附加在一个已经存在的块作用域上的行为是**隐式的**。=>容易**导致代码变得混乱**（随意移动这些块或者将其包含在其他的块中）=> 为块作用域**显示地**创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。

**显示的块作用域风格**非常容易书写，并且和其他语言中块作用域的工作原理一致。

```javascript
var foo = true;
if (foo) {
  { // <-- 显示的块
    let bar = foo * 2;
    bar = something( bar );
    console.log( bar );
  }
}
console.log( bar ); // ReferenceError
```

只要声明是有效的，在声明中的任意位置都可以使用`{...}`括号来为`let`创建一个用于绑定的块。=>整个块都可以方便地被移动而不会对外部`if`声明的位置和语义产生任何影响。

**let作用域或let声明**（对比前面的let定义）

```javascript
let (a = 2) {
  console.log( a ); // 2
}
console.log( a ); // ReferenceError
```

和隐式地劫持一个已经存在的作用域不同，`let`声明会创建一个显式的作用域并与其进行绑定。=> 更加突出，在代码重构时也表现得**更加健壮**。=> 在语法上，通过强制性地将所有变量声明提升到块的顶部来产生更简洁的代码，这样<u>更容易判断变量是否属于某个作用域</u>。

let声明并**不包含在ES6中**。官方的Traceur编译器也不接受这种形式的代码。解决办法：

1. 使用合法的ES6语法并且在代码规范上做一些妥协。🌰：

   ```javascript
   /*let*/ { let a = 2;
     console.log( a );
   }
   console.log( a ); // ReferenceError
   ```

2. 编写显式let声明，然后通过工具将其转化成合法的、可以工作的代码。**let-er工具**

**提升**：是指声明会**被视为**存在于其所出现的作用域的<u>整个范围内</u>。（第4章）

使用let进行的声明**不会**在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。

**作用**：

1. 垃圾收集

   另一个**块作用域非常有用的原因**和闭包及回收内存垃圾的回收机制相关。🌰：

   ```javascript
   function process (data) {
     // ...
   }
   var someReallyBigData = {
     // ...
   };
   process( someReallyBigData );
   var btn = document.getElementById( "my_button" );
   btn.addEventListener( "click", function click(evt) {
     console.log( "button clicked" );
   }, /*capturingPhase=*/false );
   ```

   click函数的点击回调并不需要`someReallyBigData`变量。但，由于click函数形成了一个覆盖整个作用域的闭包，JavaScript引擎极有可能依然保存着整个结构（取决于具体实现）。

   块作用域可以让引擎清楚地知道没有必要继续保存someReallyBigData了。

   ```javascript
   // ...
   { // 在这个块中定义的内容完事可以销毁！
    let someReallyBigData = {
     // ...
    };
    process( someReallyBigData ); 
   }
   //...
   ```

   为变量显式声明块作用域，并对变量进行本地绑定是非常有用的工具。

2. let循环

   一个`let`可以发挥优势的典型例子

   ```javascript
   for (let i=0; i<10; i++) {
     console.log( i );
   }
   console.log( i ); // ReferenceError
   ```

   for循环头部的let不仅将 i 绑定到了for循环的块中，事实上它将其**重新绑定**到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。

   每次迭代时进行重新绑定的行为与以下形式类似：

   ```javascript
   {
     let j;
     for (j=0; j<10; j++) {
       let i = j; // 每个迭代重新绑定！
       console.log( i );
     }
   }
   ```

   由于let声明附属于一个新的作用域而不是当前的函数作用域（也不属于全局作用域）=> 用let来替代var进行重构需要小心

   **let显式定义或let声明**

#### 3.3.4 const

ES6引入的const也可以用创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。



### 3.5 小结

块作用域：变量和函数不仅可以属于所处的作用域，也可以属于某个代码块。

根据需要选择使用何种作用域=>刻度、可维护